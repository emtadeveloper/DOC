/*

متد های استاتیگ static

1-   ما از این متد ها می توینم بیایم و قبل از نمونه ساختن از یک کلاس بهشون دسترسی داشته باشیم ولی دو تا ایراد برای این متد ها  وحود دارد  تضاد با مفهوم شی گرایی 
اشتراک داده بین همه داده ها دلیلش ام این هست که وقتی یک شی ساخته میشه باید  رفتار و منطق اش متعلق به خودش باشه  که این خاصیتاش با شی گرایی در تصاد هستش 
متدهای از نوع استاتیک به پروتایپ های کلاس ما اضافه نمی شوند و می توانیم با بررسی پروتو شی ساخته شده مطمئن شویم که متد استاتیک رو نمیبینیم چون این متد ها به کلاس
 ما اضافه می شوند نه به پروتوتایپ کلاس پس نمیتوانیم
از طریق ساخت شی صداشون بزنیم

معضل گم شدن This 
وقتی ما در داخل یک متد کلاس میایم و برای دسترسی از دیس استفاده میکنیم هنگام نمونه گیری از این کلاس اصطلاحا اون دیس میاد و گم میشه و سر این اتفاق باید از راه حل های 


زیر استفاده بکنیم که برای حل این مشکل دو تا راه داریم یکی 

1- استفاده از bind()

2- بیایم و در کلاس هامون از  arrow function ها استفاده بکنیم

نکته : اجزای تشکیل دهنده یک کلاس
class MyClass {
prop = value // property
constructor(...){ // constructor
//...
}
method(...){} // method
get something(..){} // getter method
set something(..){} // setter method
[Symbol.iterator](){} // method with computed name (symbol here)
}

در حالت سختگیرانه توابع هیچ دسترسی به دیس ندارند حتی اگر این دیس برای یک تابع سازنده بیاد و باشد 


 */
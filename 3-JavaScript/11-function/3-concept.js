/*

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
========================================================================================================




میگویند nesting به قابلیت تعریف اسکوپ های تو در تو اصطلاحا 

global scope :   lex x = 2             block scope :   {  let x = 2 ;   console.log ( x )  }

نکته : ما اگر بیایم و یک اسکوپ رو تعریف بکنیم به اسکوپ های  بالاتر از خودش دسترسی داریم  و میتونیم از اون ها استفاده بکنیم

lexical Scope ( static Scope ) :   یعنی زمانی که یک اسکوپ رو میایم و تعریف میکنیم به اسکوپ والد خودش دسترسی داره  که یعنی اسکوپ 
خارج از اون فضایی که داره یا اصطلاحا هر فضایی که خارج اون فانکشن یا تابع هستش رو میان و میگویند یک تعریف دیگه که داریم این هستش  
های بالایی شو بیاد و مشاهده بکنه  local scope میتونه بیاید و و اسکوپ های بالایی که اون رو در بر گرفته اند یا اصطلاحا   local scope  که هر 

========================================================================================================

function  outerFunction ( ) {  let x = 2  console.log( x ) 
      function innerFunction ( ) {  console.log ( x ) }
      innerFunction()
}

outerFunction ( )  // 2  2

========================================================================================================

function outerFunction() {
    let x = 1;
    return function innerFunction() {
        let y = 1;
        console.log(++x, ++y);
    };
}

let func = outerFunction();

func();   // 2 2
func();   //  3 2
func();   // 4 2

========================================================================================================


function print ( ) {    alert ( a )      }

function callThePrinter ( ) {  var a = 1;   print();  }
  
var a = 2;  callThePrinter();     // 2

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

closure function :  به تابعی میگویند که میاد و یک تابع دیگه رو برگشت میده و حالا این تابعی که برگشت میده  علاوه بر متغیر های حوزه خودش به
خودش رو یادش میمونه کاربردش برای مباحث امینت و پرفورمنس  lexical scope   متغیر های حوزه بالاترش هم دسترسی داشته باشد یا اصطلاحا 

یک محدوده گسترده تری داره و ما میتونیم بیایم و با هر بار فراخوانی اون بیایم و یک مقداری رو تغیر دهیم  scope یک محدوده  closure :  نکته   

خوب حالا کافیه در داخل تابع بالا بیایم و یک تابع دیگه تعریف کنیم و در اون پردازش انجام بدیم

می شوند wrapp نکته : همه توابع در داخل جاوااسکریپت  یک جور کلوژر حساب می شوند چون بالاخره دارند توسط یک چیزی 

function factory : زمانی که ما یک تابع رو فراخوانی میکنیم میاد و یک تابع دیگه رو برای ما اجرا میکنند و  برگشتش میدهند و کارش این تابع این  هستش
 که یک اسکوپ رو برای یک تابع دیگه ایجاد میکنه

  function outerFunction ( ) {  let x = 2   console.log(x)
      return function innerFunction ( ) { console.log( x )     }     }
        
const closure = outerFunction( )
closure( )

- - - - - - - - - - - - - - - - - - - - - - - - - Example   increment

function createIncremenrt  ( ) {  let value = 0
      return function increment ( ) {   value = value + 1  console.log(value)   return value } }
      
const counter = createIncremenrt ( ) میاد و برای ما  value  وقتی این تابع رو فراخانی میکنیم داخل حافظه یک متغیر به نام 
در داخل حافظه ایجاد میکند و چون که فقط یک بار فراخوانی میکنیم در داخ حافظه یک بار قرار میکیره و تابع زیریش که کلوژر هست
همیشه به آخرین مقداری که این متغیر داره دسترسی داره  // 0

  counter()   // 1
  counter()   // 2
  counter()   // 3

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

state Closure : اومد و فراخوانی شد بتونیم به اون مقدارش در اون زمان دسترسی داشته باشیم یا  closure function  یعنی این که ما هر موقع که
مقادیری که در اون زمان هستند و کهنه و قدیمی هستند

function createIncremenrt ( ) {  let value = 0 
     return function increment ( ) {  value = value + 1   console.log(value)   const message = `Current value is ${value}`
            function logger ( ) {  console.log(message)  }
            function getValue ( ) {   return value  }
     return {  logger , getValue  }            }    }

const counter = createIncremenrt ( )    // value = 0     // func increment
  
const { logger , getValue } = counter ( )  // value = 1   // message = `Current value is 1`  // func logger1   //  func getValue1

counter ( )     // value = 2       // message = `Current value is 2`       // func logger2     // func getValue2
  
counter()    // value = 3    // message = `Current value is 3`      // func logger3     // func getValue3
    
logger ( ) // 1       getValue ( ) // 3         
  
========================================================================================================

state Closure یک نمونه دیگه از استفاده از مفهوم 

function getAdder ( i ) {  return function ( number ) {   return i + number  }  }
    
const adder5 = getAdder(5)     const adder10 = getAdder(10)

console.log ( adder5 ( 5 ) )

console.log ( adder10 ( 5 ) ) 

========================================================================================================
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

5- Self-Invoking Functions

7- Anonymous functions

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 IIFE :  Immediately Invoked Function Expression : به تابعی گفته میشه که به محض اینکه تعریف شد فراخوانی بشه نوشتن اون خیلی ساده هست
 کافیه تعریف تابع رو بین دو پرانتز باز و بسته قرار بدیم   ( function ( ) {  } )( );

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Higher order functions : توابع مرتبه بالا به توابعی گفته میشه که می‌تونن یک تابع رو به عنوان ورودی بگیرن و یا یک تابع رو به عنوان به خروجی بفرستن
یعنی عملا یک تابع رو میگیرند یکسری تغیرات داخل اش میدهند و بعد یک تابع رو برگشت میدهند

function higherOrderFunction(param, callback) {   return callback(param);  }
  
First order functions برعکس توابع مرتبه بالا توابع مرتبه اول یا  هستن که نه تابعی رو به عنوان ورودی می‌گیرن و نه تابعی رو به خروجی می‌فرستن

Side-Effects : Making an API call / Mutating data / console logs to the screen / Manipulating the DOM
Date.now() to get current date/time / async await calls / waiting for promises to resolve / math.random( ) to generate random numbers

pure function : ای ندارند و هیچ وقت مقادیری به غیر از ورودی خودشون رو نمیان و تغیر نمیدهند و یا تعریف پایین sideEffect توابعی هستند که اصطلاحا هیچ 
به توابعی میگویند که دو شرط زیر رو داشته باشند  pure  توابع 

1 : یک تابع فقط و فقط زمانی می تواند خالص باشد، که تنها چیز هایی که برای محاسبه خروجی اش استفاده می کند، آرگومان هایی که شما به آن می فرستید 
و متغیر های داخلی که داخل خود تابع تعریف شده اند باشند

2 : را خارج از خودش تغییر ندهد state  یک تابع فقط و فقط زمانی می تواند خالص باشد که

کردن را انجام دهند log  یا  I/O، AJAX، DOM   هستند نمیتونند بیان و کارهای زیر را انجام بدهند  pure  نکته  : توابع که 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Memoization :  یعنی یک تابعی بسازیم که قادر باشه مقدار یا خروجی قبلی پردازش  شده‌ی خودش رو به یاد داشته باشه از خوبی استفاده از  ینه که هر دفعه
که تابع با آرگومان‌های مشخص فراخونی بشه دیگه عملیات اضافی صرف  محاسبه‌ی مجدد خروجی نمیشه که اینکار باعث صرفه‌جویی  در زمان میشه اما ممکنه 
مقدار  بیشتری از حافظه اشغال بشه
 
function memoize( fn) {
    const cache = {};
    return function (param) {
        if (cache[param]) {
            console.log('cached');
            return cache[param];
        } else {
            let result = fn(param);
            cache[param] = result;
            console.log(`not cached`);
            return result;
        }
    }
}
 
const toUpper = function(str) {
    return str.toUpperCase();
}
 
const toUpperMemoized = memoize(toUpper);
 
toUpperMemoized("abcdef");
toUpperMemoized("abcdef");

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*/
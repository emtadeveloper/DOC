/*
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ما به طور کلی دو نوع تعریف توابع داریم 

- regular function  یا توابع منظم         //         - Generator function 

توابع عادی زمانی که اجرای اونها شروع بشه، باید تا آخر اجرا بشه و ما تا پایان اجرا شدن هیچ کنترلی روی اونها نداریم

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

یکسری توضیع جداگانه دارد  regular function  حال خود توابع منظم 

1- function expression  :  در این حالت ما میایم  و کل تابع رو به یک  متغیری میایم و متصل اش میکنیم و اون تابع باید مقدارشو بریزه تو اون متغیر 

let example = function ( ) {  }     //     let example(){}
   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2- function declration  ما تو این حالت به خاطر مبحث هوستینگ در جاوااسکریپ  می تونیم تابع رو بالاتر از اون جایی که تعریف کردیم بیایم و استفاده کنیم
   
  function emad ( ) { }

Hoisted  :   قرار میگیرد این تابع میاد و در بالاترین سطح فایل ما قرار میگیرد و به خاطر همین   initlize  وقتی ما میایم و توابع رو به صورت سازنده تعریف میکنیم در مرحله 
هم تعریف می شوند هم صدق میکند  var  ما می توانیم بیایم و توابع رو قبل از جایی که تعریف اشون کردیم هم صداشون  بزنیم این قاعده برای متغیر هایی که با کلمه کلیدی 
اون میاد و بالا قرار میدهد declar اتفاقی که میوفتند این هست که اون 

var color = "Yellow";
(  function ( ) {    if (typeof color === "undefined") {          var color = "Green";      }
    alert(color);  } ) ( );  //Hoisting  به خاطر  green  پاسخ درست  


در یک تابع معمولی صدا بزنیم میاد و به آبجکت گلوبال  this   میاد و به یک مرحله بالاتر یا اصطلاحا صاحبش اشاره میکنه برای مثال اگر  this  نکته : در توابع معمولی 
و به اون شی اشاره میکنه و در توابع سازنده هم اگر به عنوان یک متد this اشاره میکنه ولی اگر این تابع در داخل یک ابجکت و به عنوان متد اون تعریف شده باشد این
باشد همین طور هستش 

// this refer to the  object  that  is executing  the function !   this  رفرنس پیدا میکنه به اون آبجکتی که اون فانکشن رو اجرا میکنه

( مقدار دیس به ابجکتی اشاره میکنه که داره اون تابع رو اجرا میکند )



به آبجکت گلوبال اشاره نمیکنه و بلکه مقدار  تعریف نشده هستش this نکته : در حالت سختگیرانه جاوااسکریپت مقدار 
 
 let obj = {  sayShow ( ) {   name = "emad";  family = "tag";
          
          function Show() {  console.log( "my name", this.name, this.family );    }   Show();   },   }

obj.sayShow();

this is a Object  that the function is property of 

به تابع اشاره داره که اون تابع یک پراپرتی از محیط گلوبال هستش this برای مثال در تابع بالا 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3- Recursive  Function  توابع بازگشتی یا اصطلاحا ریکاسیو فانکشن 

توابعی هستند که میان و خودشون خودشون رو صدا میزنن مثل مثال قیمت نانوایی  و اون توابع که هنو جواب ندارن در کال استک برنامه ذخیره می شوند تا به جواب برسند
این صدا زدن ها ادامه پیدا میکنه تا به یک حالت ابتدایی که در داخل خودش جواب داره بیاد و برسه در غیر این صورت تا بینهایت خودش رو صدا میزنه 

در نوشتن توابع بازگشتی ما باید چند مسئله رو مدنظرمون داشته باشیم 

1- حالت اولیه  یا ابتدایی که در واقع شرط پایان الگوریتم هستش و در این حالت  دیگه تابع خودش رو فراخوانی نمیکنه بلکه میاد و اون جواب مسئله رو ریترن میکنه
  
2 - استفاده از گام های بازگشتی هستش که باید بیایم و طوری اون هارو بنویسیم  که اصطلاحا به مرحله ابتدایی یا اولیه تابع امون هی بیایم و نزدیک تر بشیم   

3 - الگوریتم بازگشتی مثل یک حلقه تکرار هستش و از توابع بازگشتی بهتره موقعی  استفاده کنیم که خوانایی و درک بهتر کد رو ایجاد کنه 

برای  نمونه صدا زدن یک تابع بازگشتی برای جمع اعداد 1 تا  متغیرش

function sum( num ) {   if (num === 1) {  return 1   } else {    return num + sum( num - 1)   }  }    console.log(sum(4))  //10

function pow(num, arg) {    if (arg == 1) {   return num;   } else { return num * pow(num, arg - 1);  }  }    console.log(pow(3, 2));  //  9

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

4- arrow function  توابع فلش دار
 
نکته : اگر خطوط کدمون در این نوع توابع یک خط بود نیازی به ریترن و آکولاد در آن نیستش و اگر آرگومنت یکی باشه نیازی به پرانتز نیستش

نکات کار با توابع فلش دار

1 -   رو ندارند اصلا arguments توابع فلش دار کلمه کلیدی 

2 - بالایی شون رو میگیرند یا اصطلاحا اون رو به ارث می برند برای مثال ما در  داخل lecical scope  مختص به خودشون رو ندارند و میان و اون مقدار this توابع فلش دار میاد و موقع گرفتن 
در داخل کد زیر  در جایی که کال بک فانکشن برای تایمر استفاده میکنیم دیس ما چون به خود تابع اشاره میکنه و گم میشه و در نهایت مقدار برامون بر نمی گردونه 

var name = "Covey";     

const person = {  name: "Stephen",   getName: function( ) {    alert(this.name);   }    }             person.getName( )         //    Stephen        

const person2 = {  name: "Stephen",   getName: ( ) => {    alert(this.name);   }    }           person2.getName( )                //    Covey

3-  استفاده کرد برای این دلیل که اصولا توابع فلش دار پروتوتایپ ندارند و نمیتوان در اون ها از پروتوتایپ ها استفاده کرد constructor از توابع فلش دار نمی توان به عنوان توابع سازنده یا

function dump ( ) {  console.log(message)  }        console.log(dump.hasOwnProperty('prototype'));

let dump = message => console.log(message)    console.log(dump.hasOwnProperty("prototype"))
        
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*/

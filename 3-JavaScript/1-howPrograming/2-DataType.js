/*

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ما به طور کلی دو نوع داده در جاوااسکریت  داریم
 
1 - Primitive Type :  string    boolean     number    undefined    null   Symbol  NaN

2 - Refrence Type :  function  object  array

برای بهتر فهمیدن این موضوع در ابتدا میایم و کاربرد های اون هارو بررسی میکنیم  undefined VS null تفاوت های مقادیر نوع داده ای 
  
undefined :  به عنوان مقدار پیش فرض به هرچیزی که بهش مقداری تخصیص ندادیم داده میشه حالا از توابع تا متغیر ها یا پراپرتی اشیا
 
null : به عنوان نماد داده های پوچ  یا خالی هستش که میتونیم بیایم و به متغیر هامون بدهیم
 
null == undefined;    // true  هستند falsy  چون هردو اصطلاحا  

null === undefiend   // false  به این خاطر که ماهیت اصلی مقدار نال برابر با یک آبجکت هستش ولی  تعریف نشده همون تعریف نشده هستش 

هست و به معنی بی معنا بودن هستش و موقعی میایم و به این خطا بر میخوریم که یک ضرب مقدار عددی رو NaN  نکته : تنها یک مقدار در جاوااسکریپت هستش که خودش با خودش برابر نیست و اون 
روی یک مقدار غیر عددی بیاد و اعمال بشه که این خروجی رو برای ما ایجاد میکنه

{} * undefined;       //        {} * null;    //        '' * 'a';        //       1 + NaN;        //        1 + undefined;          //        undefined + null;         //          1 * {};

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
=========================================================================================================================================
در چی هستش  Refrence  و  Primitive  سوال : تفاوت اصلی داده های از نوع 
=========================================================================================================================================

خوب برای بهتر فهمیدن تفاوت های این ها بهتر هستش که بیایم و نحوه کارکرد هر کدوم از اون ها رو به صورت دقیق تر بیان بکنیم

1 - primitive  Type  ( im- mutate ) :   خوب در ابتدا میایم و کد زیر رو کامل توضیح میدیم که چرا وقتی خروجی میگیریم باید بیاد و همچین اتفاقی براش بیوفته

let x = 5;                 let y = x ;              x = 10               console.log(x,y)  //  10  , 5

یک مثال دیگه       const name = "ali"              name[2] = "y"                console.log(name);   کردن نیستند mutate قابل Primitive داده هایی که به صورت

باشه اون متغیر رو تو حافظه primitive هنگامی که موتور جاوااسکریپت شروع  به  تفسیر کدمون می‌کنه،  هر  وقت به یه متغیر  می‌رسه، مقدار اون متغیر رو چک می‌کنه اگه مقدار متغیر  یکی  از دیتا تایپ‌های
به عنوان یک در داخل x در اینجا پیش بینی میکنه که مقدار  y ذخیره شد نوبت به متغیر stack  داره تو حافظه  primitive  که دیتایی از نوع x به عنوان یه متغیر مستقل ذخیره می‌کنه بعد اینکه متغیر  stack  
قرار میده  و حالا هر دو تا متغیری که داریم رو میاد و به عنوان یک متغیر مستقل و جدا در نظر میگیره که هیچ ارتباطی با یکدیگر ندارند و اگر y اومده و ذخیره شده و مقدار اون رو برمیداره و برای متغیر  stack 
مقدار یکی از اون هارو تغیر بدیم مقدار دیگیری تغیری پیدا نمیکند

=========================================================================================================================================

2 - Refrence Type :  خوب برای بهتر فهمیدن این موشوع هم یک مثال میزنیم و متناسب با همون میایم و یکسری توضیحات رو میدهیم

let person = {  name: "Steven",  yerOfBorn: 1946   };      let person2 = person;

person.name = "Christopher"       console.log(person2.name);   // return Christopher

خوب همون طور که در کدبالا  توضیح داده شد وقتی موتور جاوااسکریپت میاد و به یک متغیر میخوره اول نوع  اون رو میاد و  چک میکنه که از کدوم نوع 2 دسته ما هستش  خوب  حالا اگر جاوااسکریپت به یک 
ذخیره میکنه و به جای مقدار اون حافظه میاد و آدرس heap ذخیره میکنه ولی مقدار اون رو میاد و در یک حافظه دیگه به نام stack بود ابتدا میاد و خود متغیر رو در حافظه reference متغیر  برخورد که از نوع 
امون heap پس وقتی که ما میایم و متغیر دومی رو برابر با اولی قرار میدهیم در اصل داریم یک آدرس مشترک که در حافظه pointer امون بهش میده که از این به بعد بهش میگیم heap   اون مقدار رو در حافظه 
هستش رو به جفتشون میدهیم و چون آدرس ها یکی هستند هر کدوم رو که بیایم و تغیر بدهیم دومی هم میاد و تغیر میکنه

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

خوب در داخل دو مثال بالا اگر بیایم و نگاه کنیم دلیل اصلی تفاوت شاید در  تعریف این دو تا مطلب مهم باشه

immutable primitive values  و   mutable object references 

میره GC  در تحلیل کد زیر هم اگر بیایم و نگاه کنیم در بلاک پایین  میاد و یک متغیر جدید تو حافظه ذخیره می شود و مقدار قبلی میاد و به 
    
let name = "emad";            console.log(name);   // emad         name = name + " Ta";                console.log(name);     // emad  ta

این قالیت برای ابجکت ها هم قابل صدق هستش

const obj1 = { name: "Emad" };      const obj2 = obj1;         console.log(obj1, obj2);   // Emad Emad       obj1.name = "Ali";          console.log(obj1, obj2); //  Ali   Ali

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

برای مشخص کردن نوع داده ای  توابع امون میتونیم بیایم و از دو تا تابع زیر استفاده بکنیم 

1- TypeOf :  مشخص میکنه مقداری که بهش پاس داده شده از چه نوعی هست و یک رشته رو برگشت میدهد که نشان دهنده نوع تایپ هستش

console.log(typeof 3 );    number   //    console.log(typeof  "Hello" );     string    //     console.log(typeof { } );     object//     console.log(typeof  [ ] );   object

console.log( typeof null );     object   //    console.log( typeof undefined );   undefined

2- instanceOf  : prototype برمیگردونه البته درست تر این هست که چک میکنه که آیا داخل bool  تست میکنه که آیا آیکجت از نوع وارد شده هست یا نه و در نهایت نتیجه رو به صورت یک
ها یک خورده مشکل داره و برای اعداد primitive  که مشخص کردیم وجود دارد یا نه و بهتر هستش که اون رو برای آبجکت ها استفاده کنیم چون برای   prototype  property  یک object یک
مقدار نادرست برمیگردوند

console.log( function ( ) { } instanceof Function);   true     //     console.log ( " string " instanceof String );   false     //    console.log ( [ 2 ] instanceof Array);   true

console.log(obj= { } instanceof Object)    true    //     console.log ( 12 instanceof Number );  false

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

*/

/*
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
wrapper  :  ما یکسری نوع داده ای داخل جاوااسکریپت داریم مثل رشته عدد بولین که دارای متد و پراپرتی هستند در حالیکه این ها ماهیتا اصلا شی نیستند
دارند دلیلش هم این هست که این نوع های داده ای به طور موقت داخل یک ابجکت میرود که به این toUpperCase length مثلا برای رشته ها که متد های  
هستش میرن و در اون ها این متد ها قابل استفاده می شوند و بعد از فرخوانی پراپرتی یا متد از بین هم میروند Wrapper object  شی موقت اصطلاحا 

var mein = "dein";       alert(new String(mein).toUpperCase()); // DEIN

===========================================================================================================

خوبه ما به 3 روش کلی میتونیم بیایم و اشیا امون رو تعریف کنیم

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1- literal Object  : ما معمولا برای استفاده از اشیاء از این روش میایم و استفاده میکنیم 

let literal_object = {    property   :   behavior   }

اگر ما خواستیم بیایم و از یک نام در پراپرتی هامون استفاده کنیم که از دو کلمه تشکیل شده باشد باید در داخل دابل کوتشین اون رو قرار دهیم  
و موقع فراخوانی هم از  از براکت استفاده کنیم  

let literal_object = {   "property emad": 'behavior'   };          console.log( literal_object [ " property emad " ] );         // behavior

selected Property  و computed Property مفاهیم 

computed property  : میگه که ما میخایم بیایم  و یک متغیری رو به عنوان  کلید به یکی از پراپرتی های یک شی بدهیم 

const myPropertyName = 'name'
const myObject = {   num: 1  ,  [ myPropertyName ]: "emad" }           console.log(myObject.name)    // emad

selected Property  حال اگر در مثال بالا بیایم  و اون رو به این صورت قرار بدهیم میشه

console.log(myObject[ myPropertyName ])    // emad

obj = { emad( ){  }  }  اگر ما خواستیم بیایم و یک تابعی رو در داخل شی به عنوان متد قرار بدهیم بهتر هستش به شیوه زیر از اون استفاده بکنیم

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
2-  Factory Function :  تابع می نویسیم که از روش هر مدل شی که خواستیم بسازیم و نیازی به تغیر دادن به صورت دستی  و کپی کردن
بنویسیم camel Case    نباشد ما برای تعریف توابع امون میتونیم بیایم و اون هارو به صورت 

function  createCircle ( radius ){   
  return  {   radius   move ( ) {  console.log( "move function" )  }   }
} 

const   circle1  =   createCircle(1)   //  const   circle2  = createCircle(2)  c  onsole.log(circle1)   //  console.log(circle2)

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-  Constructor Function :   میایم و تعریف میکنیم PascalCase توابع مادر که اون هارو به صورت  

function Circle (radius){  this.raduis = radius ;  this.move = function ( ) { cinsole.log("move")    } }
   
 const  circle = new Circle(3)  // {}
 
 // 1.  new
 // 2.  {}
 // 3.  this points th this emty object {}
 // 4.  return this objec

استفاده میکنیم یک سری اتفاقا میوفته اول اینکه میاد و برای ما یک شی خالی رو درست  new  در توضیح کد بالا وقتی که ما میایم و از کلمه کلیدی 
میسازه که این کیوبرد میاد و اشاره میکنه به اون شی خالی که ساخته  و در آخر هم به صورت اتوماتیک شی امون this  میکنه و بعد میاد و یک کیبورد 
رو قرار بدیم خودش این کار رو برامون میکنه  return this  رو بر گشت میدهد و دیگه لازم نیست که بیایم و به

 console.log(circle)

===========================================================================================================
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
===========================================================================================================

Dynamic Objects :   این که برای پراپرتی دادن به یک شی بیایم و بیرون از اون این کار رو انجام بدهیم رو میگویند

const circle = {   radius : 1  }        circle.color = "red"  circle.draw = function ( ) {  }        delete circle.color         console.log(circle)

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Constructor Property  For Object

متفاوت هستش   Constructor  و  Factory   در آبجکت هایی که به دو صورت   Constructor   رفتار تابع 

//Factory Function

function  createCircle(radius){       return  {   radius   move( ){  console.log("move function")  }   }  } 

const   circle1  = createCircle(1) 

circle1.constructor  میاد و اشاره میکنه به تابع سازنده اصلی  یا اولین کد سازنده که میشه یکی 

پایینی  //     object ( ) {  [  native code  ]}

// Constructor Function

function Circle ( radius ) { this.raduis = radius  ;  this.move = function ( ) { console.log("move")    } }
   
const  circle2 = new Circle (3)

circle2.constructor   شده new میاد و اشاره میکنه به تابع سازنده یا مادرش که از اون اومده  و اصطلاحا 

===========================================================================================================
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Cloneing Object :    وقتی که ما میخایم بیایم  و یک آبجکت رو اصطلاحا کپی بکنیم ولی این کپی در رفرنس اصلی اون ایجاد نشه باید بیایم و از این
روش استفاده بکنیم یعنی قبلا اگر میخاستیم بیایم و یک کپی رو ایجاد بکنیم این کپی میومد و در رفرنس اصلی هم ایجاد میشد که بنابر این اگر اون شی
رو تغیر میدادیم شی اصلی مون هم تغیر میکرد

===========================================================================================================

- for in   :::::::   

const user = { name : "emad"  ,  age :  24 }            const user2 = { }

for ( key  in   user ) {   user2 [ key ]  =  user[ key ]   }       user2.age = 26

console.log(user2)         console.log(user)

===========================================================================================================

- assign ::::::: 
این تابع میاد و عمل کپی کردن رو برای ما انجام میده و چند تا آرگومنت میگیره اولی تارگت یا هدف هست و بعدی ها اشیایی هستش که باید در آن ها عمل کپی کردن
رو انجام دهیم object.assign ( obj1,obj2 )  

let obj1 = {   name: "emad"   };     let obj2 = { name: "ALI",    family: "taghipour", };
Object.assign(obj1, obj2));                  console.log(obj1);         console.log(obj2);

const user = { name : "emad"  ,  age :  24 }        const user2 = Object.assign({},user)
user2.age = 27    console.log(user)

===========================================================================================================

- spread  ::::::: 
 هم استفاده میکنیم  combinnig  به معنای دسترسی به آیتم های یک آرایه یا یک آبجکت  با استفاده از 3 نقطه این مفهوم چند تا کاربرد داره از این قابلیت برای  

  - کپی کردن آیتم های یک آرایه یا یک شی در یک شی یا آرایه دیگه هستش
  - الحاق کردن دو تا آرایه یا دو تا آبجکت 
  - گسترش عناصر در کنار هم با یک عنصر منفرد
  - خالی کردن یک آرایه به شیوه  arry1 = [...[ ] ]   obj1 = {...{ } }

const user = { name : "emad"  ,  age :  24 }        const user4 = {...user}    console.log(user4)

let obj1 = {  name: "emad", family: "ta", age: 24,    };  console.log(obj1);
let obj2 = {   ...obj1,     sayName() {     return this.name + "" + this.family;    },  };
console.log(obj2.sayName());

let array1 = [1, 2, 3, 4, 5, 6];   let array2 = [...array1, 7, 8];    console.log(array2);
      
===========================================================================================================

در اشیا به خود اون شی میاد و اشاره میکند ولی مواقعی که به صورت کال بک هستند موقعی که میایم و از این مفهوم میخایم بیایم و استفاده کنیم بهم this کلمه کلیدی
میخوره که باید از مفهوم بایندینگ بیایم و استفاده کنیم 

هستش که برای پیمایش میایم و از اون استفاده میکنیم  که دو تا پارامتر میگیره اولی یک تابع هستش که بگیم بیاد و برای همه  map  گفتیم شبیه به متد  forEach 
در داخل اون مشخص کنیم  this اعمال و شه و دومی هم میتونیم به عنوان رفرنس 

const person = {  _name : "saheb",  students : ["a","b","c"],
  teach () {
    this.students.forEach(function(student){
      console.log(this._name , student)
    },this)
    }
}

person.teach()

===========================================================================================================
*/

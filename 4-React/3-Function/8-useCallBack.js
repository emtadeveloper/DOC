/*
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

این هستش که بتونیم بیایم و از ساختار های پیچیده  یا کامپلکس رو در داخل ری اکت با هم مقایسه بکنیم که این ساختار های یچیده توابع آرایه ها و آبجکت useMemo  یکی دیگه از کاربرد های استفاده از 
هستند Refrence   ها هستند که به صورت  

خوب در داخل پیاده سازی کد زیر اگر ما بیایم و روی هرکدوم از دکمه ها کلیک کنیم باعث میشه که کامپوننت ما بیاد و رندر بشه که این رندر شدن کامپوننت پدر باعث میشه که اون کامپوننت فرزند هم بیاد و دوباره 
تعریف کنیم به جای اینکه اون رو به عنوان یک کامپوننت معمولی تعریف کنیم جلوی این آپدیت شدن رو میایم و میگیریم و تابع فرزند ما pureComponent رندر بشه حالا  ما اگر بیایم و کامپوننت فرزند رو به شکل 
دیگه رندر مجدد براش اتفاق نمی افتد حالا اگر ما بیایم و یک تابع رو به عنوان پراپس به این کامپوننت فرزند پاس بدیم برای مثال یک تابع خالی رو می بینیم که با هر بار رندر مجدد کامپوننت پدر کامپوننت فرزند هم
ما دیگه هیچ گونه اثری رو ندارد  دلیل این کار هم این هستش که با هر بار رندر کامپوننت پدر  این تابع جدید میاد و دوباره در حافظه قرار میگیرد و یک مقدار pureComponent میاد و رندر میشه و دیگه اون کامپوننت
جدید رو به عنوان پراپس میاد و پاس میده پس همیشه این اتفاق می افتد

استفاده بکنیم که یک بار دفعه اول تابع ما میاد و اجرا میشه و دفعه بعدی چون مقدار رفرنس یکی هست باعث میشه که دیگه باعث رندر مجدد کامپوننت useMemo  خوب برای رفع این مشکل میتونیم بیایم و از
فرزند رو بگیره

بیایم و تابع امون رو به خارج از کامپوننت useMemo خوب ما باید بیایم و زمانی از این قابلیت استفاده بکنیم که ما نتونیم تابع امون رو به خارج از کامپوننت امون منتقل بکنیم یعنی در کد زیر اگر به جای استفاده از 
امون مثلا تکه کد بالاش انتقال بدیم می بینیم که درست کار میکنه

که دقیقا همین کار رو برای ما میاد و انجام میده ولی تنها تفاوتی که داره اون تابعی که بهش پاس میدهیم useCallBack  خود ری اکت اومده و برای ما یک تابع دیگه رو به وجود آورده به نام 
رو خودش اجرا نمیکنه و فقط میاد و اون رو برگشت میدهد
const handle = useCallBack(function handle () {  } , [ ])  

export default function App() {

    const [counter1, setCounter1] = useState(0);
    const [counter2, setCounter2] = export default function App() {useState(0);

      const handle = useMemo(()=> function handle () {  } , [ ])  
      const handle = useCallBack(function handle () {  } , [ ])  


    return (
        <div>
            <p>Click count1 : {counter1}</p>
            <p>Click count2 : {counter2}</p>
            <div>
                <button onClick={() => setCounter1((c) => c + 1)}> Increament1 </button>
                <button onClick={() => setCounter1((c) => c - 1)}> Descrase1 </button>
            </div>
            <div>
                <button onClick={() => setCounter2((c) => c + 1)}> Increament2  </button>
                <button onClick={() => setCounter2((c) => c - 1)}> Descrase2   </button>
            </div>
            <Child    handle = {handle}/>
        </div>
    );
}

export default function Child extends Component {
    render( ) { 
        return ( <div> Child component  :  { Math.random()})
        }
    }
}

بدیم این افکت ما هر دفعه اجرا میشه dependcy array  امون داریم و اون رو به عنوان useEffect خوب تا الان توضیحات کافی بوده حالا فرضا فکر کنید که ما همین تابع هندل امون رو در داخل 
خوب اگر ما نتونستیم اون رو به خارج از تابع یا بدنه خود افکت منتقل کنیم میتونیم از این تکنیک استفاده بکنیم

Pure Component : هستش اما در کامپوننت هایی  که به صورت true انجام نمیشه و دیفالت مقدار خروجی اش برابرر با   method should component update خوب ما در کامپوننت های معمولی امون متد 
میشه و اگر این مقدار ها تغیر کردند خروجی  متد مقدار درست هستش و false یا true  قبلی برابر با  props  و state الان با  props  و state هستند این متد اجرا میشه و خروجی اون براساس مقایسه  Pure 
کامپوننت ما میاد و ری رندر میشه

از نوع رفرنس تایپ باشه  state  امون رو تغیر بدیم فقط نکته مهمی که وجود داره اینه که اگر مقدار  state بیایم و مقدار  useState یا setState  کی تغیر میکنند وقتی که با    props  و state  حالا این مقادیر
باشه باید مقدار اون رو تغیر بدیم حالا اگر رفرنس همون رفرنس بود و مقدار همون مقدار قبلی بود کامپوننت های معمولی میان و مجدد ری رندر primitive  باید بیایم و رفرنس اشو تغیر بدیم و اگر مقدار از نوع    
ری رندر بشه Pure کردی ولی اما همون مقدار یا رفرنس قبلی رو دادی بهش پس نمیزاره دیگه کامپوننت setState دیگه ری رندر نمیشه چون میگه Pure می شوند ام در کامپوننت های 

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*/

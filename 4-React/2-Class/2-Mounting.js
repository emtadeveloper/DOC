/*
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Mounting : به ترتیب اجرا

1- contructor     2-  getDerivedStateFromProps ( مشترک در مرحله بعدی و این )     3-render ( مشترک در مرحله بعدی و این  )    4- componentDidMount

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1- contructor : امون رو انجام بدیم  این منتد فقط یک بار در طول چرخه حیات میاد و اتفاق میوفته State  نشده  و بهترین کاری که باید بکنیم اینه که بیایم و مقدار دهی های اولیه  Mount  در این فاز  ما کامپوننت امون اصطلاحا

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2- static getDerivedStateFromProps (  nextProps, preState ) :  امون بیایم و تغیر بدهیم پس در  نتیجه ما props درونی یک کامپوننت رو با توجه به state تنها کاربرد کلیدی که این کامپوننت این هستش که می تونیم که بیایم و
رو داشته باشیم sideEffect  در این مرحله نمیتونیم بیایم و هیچ گونه

نکته : این کامپوننت میاد و پیچیدگی کار ما رو به شدت بالا میبره و باعث ایجاد باگ های سخت میشه و نگه داری کدهامون هم سخت میکنه

دسترسی نداریم  و اگر متدی داخل کلاس تعریف کنیم  این جا در دسترس ما نیستش و باید به یک شیوه دیگه ازش استفاده بکنیم این کامپوننت میتونه چندین بار اجرا بشه و باید شرط this  نکته :  چون متد بالا به صورت استاتیک هستنش به 
استفاده بکنیم  setState  چک کنیم و گرنه ممکن  هستش که بیاد و چندین بار اجرا بشه ما حتما باید از قبل استیت امون رو تعریف کرده باشیم و حق نداریم بیایم و 

می شود میتونه مقادیر mount نکته : ما در داخل این کامپوننت  پراپس های قبلی رو نداریم پس ما باید پراپس قبلی با پراپس جدید باید بیایم  و چک بکنیم  دلیل اشم این هستش که چون که زمانی  که این کامپوننت داره برای اولین بار 
باشه و زمانی که بخان پراپس قبلی پاس بدن باید یک جا اون رو ذخیره کنند که با این  کار مصرف حافظه میاد و بالا میره البته قراره این حذف رو برای جاهای دیگه هم استفاده بکنند null پراپس هامون  پاس داده نشه و مقدارشون برابر با 
و برای رفع این موضوع باید بیایم و کار پایینی رو انجام بدهیم

static getDerivedStateFromProps( nextProps,preState ) { 
  if( props.userID !== state.prePropsUserID ){
      return {   prePropsUserID : props.userID,  user:null   }    }
      return null   
  }


باشه مجبور null امون بیاد و تبدیل به props  استفاده شده است این هستش که اگر این کار رو میکردن باعث میشدکه میزان مصرف حافظه امون بیاد و بالا بره و معمولا  مقادیر nextProps قبلی از props نکته : یکی از دلایل این که به جای 
به چک کردن مقادیر حافظه رو داریم

نکته : یک موقع هستش که ما میخایم با استفاده از درخواست ها و استفاده از پراپس ها و استیت ها مون بیایم و یکسری اطلاعات رو به  کاربر نشون بدهیم حال اگر این درخواست ما مدت زمان پاسخ گویی اش بیاد و طول بکشه معمولا میتونیم
بیایم و از لودر ها برای این کار استفاده بکنیم که حال اگر ما قرار باشه بیایم و یک چیزی مثلا چک بشه مثل لاگین و صحت اون اطلاعات برای ما مهم باشه که اشتباه نشه میتونیم از این کامپوننت بیایم و استفاده بکنیم به این صورت که هر موقع پراپس 
اومد  و تغیر کرد متناسب با اون هم بیایم و اطلاعات پیرامون استیت رو هم بیایم و تغیر بدهیم

constructor( props ) {   super( props );   this.state = {    user: null ,   prevPropsUserId: null,     };      }
       
static getDerivedStateFromProps(nextProps, prevState) {
        if (nextProps.userId !== prevState.prevPropsUserId) {
            return {  user: null,   prevPropsUserId: nextProps.userId,   };   }  return null;      }
 
استفاده میکردیم  که البته ما میتونیم  بیایم و در این جا از یک list rendering ها هستش  که البته تا قبل از این ما میومدیم و  از کلید ها در حلقه ها و key نکته : البته یک راه برای جایگزینی در این راه هستش که اون هم استفاده از کلید ها یا 
خاصی که برای این قسمت اومده و تعریف شده رو استفاده بکنیم هنگامی که مقدار کلید ما میاد و تغیر میکنه ری اکت به طور خودکار میاد کامپوننت قبلی رو حذف میکنه  و یک کامپوننت جدید رو برای ما میسازهuseCase  

نکته : در مثالی که متناسب با این کامپوننت هست وقتی ما میایم و از روش جایگزین اون یعنی کلید ها استفاده میکنیم و با تغیر اطلاعات باعث میشه که کامپوننت ما بیاد و نابود بشه و بیاد و دوباره ساخته بشه که اگر بیایم و یک کامپوننت 
 هم نداریم  componentDidUpdate  درست  بکنیم و در اون لاگ بگیریم متوجه این موضوع می شویم با این راه حل دیگه نیازی هم به تعریف کردن کامپوننت componentWillUnMount  

نکته : حال چه زمانی باید ازش استفاده بکنیم بستگی به شرایط دارد هر موقعی که ساخت زمانی این کامپوننت ما به وسیله درخواست به سرور امون میاد و بیشتر طول میکشه و پروسس زیادی داریم که بهتره بیایم  و این کامپوننت  همراه با آپدیت 
استفاده بکنیم ولی هر موقع که ساخت کامپوننت جدید برای ما هزینه زمانی زیادی نداشت بهتر هستش که از کلید ها استفاده بکنیم

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3- render می‌شوند  DOM   در این متد المنت‌ها آماده‌ی نصب در 

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

4- componentDidMount  :  و درخواست های ایجکس در داخل برنامه امون  و یا ارسال  درخواست state قبل از نشون دادن خروجی به کاربرمون میاد و این متد اجرا می شود و ما میتوانیم در این مرحله روند اجرا رو تغیر بدهیم مثل تغیر  
رو فراخوانی میکنیم که با این کار تابع رندر امون میاد و دوباره  اجرا میشود و در واقع قبل دیدن کاربر کامپوننت ما دوبار تنها رندر میشه و   SetState به سمت سرورمون که معمولا کاری که میکنیم این هستش که بعد از ارسال درخواست بیایم و
کاربر فقط رندر دوم رو میاد و مشاهده میکنه    

-  کامپوننت ما لود شده ولی این خروجی به کاربرمون نمایش داده نشده 
-  بهترین جا برای نشان دادن و ارسال درخواست های سمت سرومون
-  SetState مجاز به استفاده کردن از تابع 
- قبل از مشاهده کردن تغیرات توسط کاربر این کامپوننت امان دو بار رندر می شود و کاربر رندر دوم رو می بیند
-  استفاده بکنیم setInterval  میتونیم بیایم و از تابع 
- برای اندازه گیری کردن یک سری مقدار ها و تول تیپ ها و مودال ها میتونیم بیایم و استفاده بکنیم

constructor(props) {  super(props);   this.state = { info: null ,     isLoading: true   }}
   
componentDidMount() {   getInfo().then(data => {   this.setState({    info: data, isLoading: false      })    })}         

در داخل این چرخه باید خیلی احتیاط کنیم دلیل اون هم این هستش که میادو پرفورمنس مارو میاره پایین چون رندر رو دوبار انجام میدهد SetState نکته : در هنگام استفاده از           

درست کنیم و درخواست های سرورمون رو در آن قرار دهیم در داخل این پوشه درخواست هامون services  نکته : ما میتونیم برای درخواست های سرورمون بیایم و یک پوشه به نام
رو به شکل فانکشتال در جی اس انجاممیدهیم

async function getIp ( ) {
const response = await fetch('https://api.ipify.org?format=json');  
const iresponse_ip = await response.json()).ip;
return  iresponse_ip  }
  
async function getInfo ( ) {
const ip = await getIp( ) ; const response = await fetch(`http://ipwhois.app/json/${ip}`)
return await response.json ( ) ;  }

export default getInfo;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*/

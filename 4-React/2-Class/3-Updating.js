/*
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Updating : تغیرات props state

1- getDerivedStateFormProps ( مشترک با مرحله قبلی )         2- shouldComponentUpdate           3- render (مشترک با مرحله قبلی )          4- getSnsapshotBeforeUpdate
      
5- componentDidU pdate(prevProps,prevState) 
      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  

1- getDerivedStateFormProps ( مشترک با مرحله قبلی ) 

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2-shouldComponentUpdate : هستش که به معنی راه فرار هستش که زمانی که  ما از این  Escape hatch  خروجی این متد یک مقدار بولین  هستش که اگر درست باشد کامپوننت ما دوباره رندر می شود یکی از القاب  این کامپوننت
کامپوننت استفاده میکنیم به خاطر اضافه شدن یک لاجیک دیگه باعث میشه که پرفورمنس برنامه ما بیاد و کاهش پیدا بکنه و موقع استفاده از این کامپوننت  نگه داری از کدهامون میاد وسخت میشه و چون ممکن هستش که بیایم و پراپس ها
و یا استیت هامون رو تغیر بدهیم این تغیر و عدم تغیر اون میتونه بعدا بیاد  و برامون مشکل ساز بشه و ما باید بیایم و دقیقا موقعی از این کامپوننت استفاده   بکنیم که میزان پرفورمنس ما افزایش پیدا بکنه 

shouldComponentUpdate ( nextProps,nextState ) {   if( this.props.color !== nextProps.color ) {   return true    }    if( this.State.count !== nextState.count ) {   return true     }       return false }

هستش ولی ما ture این لاجیک به صورت پیش فرض برابر با  React.Component  از اون استفاده بکنیم چون در داخل کامپوننت های  pureComponent  نکته : برای استفاده از این کامپوننت بهتر هستش که ما بیایم و در داخل کامپوننت      
رو انجام بدهیم state  و props میتونیم بیایم و عمل چک کردن مقدار های Pure  در داخل کامپوننت های   
 
هست که به معنی مقایسه سطحی و کم عمق پس اگر ما در داخل پراپس هامون بیایم و از مقادیری مثل آبجکت ها یا آرایه ها  استفاده بکنیم این shallow comparison  هستش از نوع  pureComponent  نکته : مقایسه های که در داخل 
مقادیر برابر نمی شوند طبق مثالی که در زیر آوردیم

nextProps = {   user: { name : 'mojtaba     }  }       preProps = {   user: { name : 'mojtaba     }    }

نکته : ما میتونیم بیایم و  از این کامپوننت برای مقایسه در کامپوننت های عادی مون هم بکنیم

export default class A extends Component {
  shouldComponentUpdate ( nextProps ,  nextState ) { 
      if ( nextProps.number ! == this.props.number ){  return true       }     return false  }   }
           
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3- render

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

4-getSnapshotBeforeUpdate : ما  میتونیم بیایم و  اطلاعات مربوط به دام امون رو بیایم و آپدیت اشون بکنیم بیشتر کاربرد این متد در  استفاده از اسکرول هستش 

class CustomTextInput extends React.Component { 
   Constructor( props ) {  
      super(props) 
       this.listRef = React.createRef( ) 
      }

getSnapshotBeforeUpdate( prevProps,prevState ) { 
        if( preProps.list.length <  this.props.list.lengtyh ){
           const list = this.listRef.current  return list.scrollHeight - list.scrollTop 
            } return null  }
   
componentDidUpdate( prevProps,prevState,snapshot ) {   
   if(snapshot !== null){   
      const list = this.listRef.current
     list.scrollTop = list.scrollHeight - snapshot
  }   }

render ( ) {   return (   <div ref={this.listRef}>  {..... content ......}     </div>     )  }
   
هر موقع که ما نیاز داشتیم که بیایم و یک سری اطلاعات رو از شرایط موجود بیایم و قبل از بروز رسانی داام امون داشته باشیم بهتر هستش که بیایم و از  این چرخه حیات استفاده بکنیم مثل اسکرول و یا رنگ 

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

5-componentDidUpdate(prevProps,prevState) :  امون  تغیر بکنه و به عنوان مقادیر  ورودی Props یا State  اجرا می شود این متد دقیقا میاد و موقعی اجرا می شود که  updatae این تابع آخرین تابعی هستش که میاد و در چرخه 
قبلی رو میاد و میگیره برای فهم بهتر کاربرد این متد بیا و مثالی که زده شده بین ما  یک صفحه داریم که با سوییچ به هرکدومشون یک درخواست به سرورزده میشه و مطالب اون لود میشه و هر صفحه ام باز یکسری کامت ها ی  State و props
مختلفی داره که اون ها هم متناسب با هر صفحه که توسط کاربر   زده میشه باید یک درخواست جدا زده بشه برای حل این  مشکل بهتره که بیایم و از این متد استفاده بکنیم که با تغیر کردن پراپس اصلی بیاد و یک درخواست مجدد زده بشه تا اون
دیتای دومی هم بیاد و تغیر بکنه

// درخواست اولیه ام به سمت سرور با این تابع میکنیم
async getCommnets() { const comments = await fetch(  `http://localhost:3001/comments?post-id=${this.props.post.id}` );      return await comments.json();   }
    
//  عملیات ست کردن اولیه دیتا مون با استفاده از این تابع هستش
setComment() { this.getCommnets().then((comments) => this.setState({ comments }));   }
    
// اولیه امون برای دیتا امون  Mounting 
componentDidMount() {     if (this.props.post) {    this.setComment( ) ;     }     }

// updatae  درخواست دادن برای 
componentDidUpdate(prevProps) {     if (prevProps.post.id !== this.props.post.id) {  this.setComment();     }    }

رو انجام بدهیم ولی حتما باید اون رو در داخل یک شرط بیایم و قرارش  بدهیم  که در طی یک شرایط خاصی  بیاد و اجرا بشه و در غیر این صورت هر بار که کامپوننت ما رندر بشه و آپدیتsetState  ما در داخل این کامپوننت میتونیم بیایم و عمل     
 شه این اجرا می شود و داخل یک حلقه بی نهایت میاد و قرار میگیرد

دلیل اشم این State هستش نه Props امون تغیر  کرد  ما یک درخواست ایجکس رو بیایم و به سمت سرور بفرستیم البته این کار برای تغیر پیدا کردن  Props  نکته  : یکی از کاربرد های مهم این  کامپوننت این هستش که زمانی که 
رو فراخوانی میکنیم معمولا یک هندلر یا متد داریم که این عملیات بروز رسانی  رو برامون انجام میدهد و ما میتونیم همون جا همین درخواست ایجکس امون رو بفرستیم و منتظر نشیم که برسه به این setState  هستش که زمانی که  
componentDidUpdate و توصیه میشه برای افزایش  پرفورمنس اگر  ما نیاز داشتیم  که درخواستی رو  به سمت سرور  بفرستیم داخل همون هندلر امون بیایم و قرار اش  بدهیم و اون درخواست رو داخل  componentDidUpdate 
درخواست ایجکسی بفرستیم  Props میتونیم بیایم و این  کار رو بکنیم و ایرادی نداره در این چرخه حیات برای تغیر Props  قرار ندهیم ولی این کار برای تغیر کردن 

componentDidUpdate(prevProps,prevState,snapshot){ } نکته : این چرخه حیات یک متد یا پارامتر سومی هم داره  این پارامتر سوم تمام محتوای برگشت داده شده در چرخه حیات
زیر هستش getSnapshotBeforeUpdate 

رو به عنوان پارامتر getSnapshotBeforeUpdate  یک پارامتر سومی هم داره که قبلا در بارش صحبت نکردیم اون هم این هستش که میاد و تمام محتوایی  که برگشت داده میشه در داخل کامپوننت componentDidUpdate  کامپوننت 
رو انجام بدهیم return null رو برگشت بدهیم وگرنه ری اکت میاد و برای ما خطا میگیرد و بهتر هستش که اگر این مقدار رو نداریم مقدار  null  سوم بر میگردونه  اگر ما قصد نداریم که در این متد چیزی رو آپدیت بکنیم پس باید مقدار

componentDidUpdate و getSnapshotBeforeUpdate  این دو تا چرخه حیات به همدیگه وابسته هستند و باید در کنار هم بیان و استفاده بشوند

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*/
